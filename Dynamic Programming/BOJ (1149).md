# **BaekJoon Online Judge**
## RGB거리 1149번
---
#### RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.

#### 집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.

#### 1. 1번 집의 색은 2번 집의 색과 같지 않아야 한다.
#### 2. N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
#### 3. i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.

#### 첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.
---
## **_Code_**
```cpp
#include <iostream>
using namespace std;

int min(int a,int b){
  return a>b ? b:a;
}

int main(){
  int N=0;
  int RGB[1001][3]={0};                                                      //각 Red,Green,Blue의 정보를 담고 있을 배열
  int dp[1001][3]={0};                                                       //dp[i][0]은 Red, dp[i][1]은 Green, dp[i][2]는 Blue를 택했을때의 최솟값을 담는 배열
  
  cin >> N;
  cin >> RGB[1][0] >> RGB[1][1] >> RGB[1][2];
  
  dp[1][0]=RGB[1][0],dp[1][1]=RGB[1][1],dp[1][2]=RGB[1][2];                  //초기 최솟값 설정
  
  for(int i=2;i<=N;i++){
    cin >> RGB[i][0] >> RGB[i][1] >> RGB[i][2];
    dp[i][0]=min(dp[i-1][1],dp[i-1][2])+RGB[i][0];                           //Red를 선택했다고 가정 후, 이전 값의 Green과 Blue의 최솟값과 자기자신을 더한 값을 저장
    dp[i][1]=min(dp[i-1][0],dp[i-1][2])+RGB[i][1];                           //Green를 선택했다고 가정 후, 이전 값의  Red와 Blue의 최솟값과 자기자신을 더한 값을 저장
    dp[i][2]=min(dp[i-1][0],dp[i-1][1])+RGB[i][2];                           //Blue를 선택했다고 가정 후, 이전 값의 Red와 Green의 최솟값과 자기자신을 더한 값을 저장
  }
  cout << min(min(dp[N][0],dp[N][1]),dp[N][2]);                              //최종 N번째에 저장되어 있는 dp[N]행에 위치한 배열 값들중 최솟값 선택 후 출력
  return 0;
}  
```
---
## **_Key Code_**
```cpp
dp[i][0]=min(dp[i-1][1],dp[i-1][2])+RGB[i][0];   
dp[i][1]=min(dp[i-1][0],dp[i-1][2])+RGB[i][1];   
dp[i][2]=min(dp[i-1][0],dp[i-1][1])+RGB[i][2];  
```
#### Red,Green,Blue를 선택했을 때 자신을 제외한 이전의 색들과 비교해야 하므로 다음과 같이 3개의 경우의 수를 설정하고 최솟값이 구현되도록 하는 것이 Key Code!
---
## **_Comment_**
#### 처음엔 사실 2차원 배열이 아닌 1차원 배열로 풀려고 하였다. 하지만 그렇게 되다 보니 이전 값과 비교하는데에 다소 어려움이 있어 2차원 배열로 구현한 코드로 풀게 되었다. 하지만 구글을 통해 이 후 여러 해답을 보았는데 1차원 배열로 메모리를 아껴 구현에 성공한 코드를 보고 좀 더 시간을 투자해볼껄,,이라는 아쉬움이 남았다. 하지만 문제를 이해하고 풀 수 있었기에 조금 더 노련함을 쌓는다면 전자의 방식으로도 충분히 풀어낼 수 있을 것이다:-)
