# **BaekJoon Online Judge**
## 2xN 타일링 11726번
---
#### 2×N 크기의 직사각형을 1×2, 2×1 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.

#### 아래 그림은 2×5 크기의 직사각형을 채운 한 가지 방법의 예이다.

#### 첫째 줄에 N이 주어진다. (1 ≤ N ≤ 1,000)
---
## **_Code_**
```cpp
#include <iostream>
using namespace std;

int main(){
  int N=0;
  cin >> N;
  int* dp=new int[N+1];                               //N+1만큼 dp 동적할당                 
  
  dp[1]=1;
  dp[2]=2;
  for(int i=3;i<=N;i++){
    dp[i]=(dp[i-1]+dp[i-2])%10007;                    //피보나치와 같이 이전항과 이전전항을 더한값이 dp[i]임을 인지하고 값이 너무 커져 정수형 범위를 
  }                                                   //넘어갈 수 있으므로 10007의 나머지를 미리 구해주며 정수형 범위를 넘지 않도록 값을 저장해 나아가준다.
  cout << dp[N] << endl;
  delete[] dp;                                        //동적할당해제
  return 0;
}
```
---
## **_Key Code_**
```cpp
dp[i]=(dp[i-1]+dp[i-2])%10007;
```
#### 10007을 dp[N]을 구하고 출력전에 구해주는 것이 아닌, 계산횟수가 많아지더라도 정수형 범위로 인해 원하는 값을 반복문 후에는 도출할 수 없음을 인지하고 10007을 나눠 얻은 나머지값을 dp[i]에 저장해주며 답을 얻어 나가는 것이 Key Code!
---
## **_Comment_**
#### 처음 이 코드의 알고리즘을 구현하는 것에는 어려움이 없었으나, 이상하게 틀렸다고 나와 이유를 찾지 못하였다. 나는 dp[N]을 구한 후 마지막에 한번 10007을 나눠 나머지를 구해주었는데, 그렇게 되면 N이 커질 때 값이 정수형 범위를 넘어감을 인지하지 못하였다. 후에 정수형 범위를 넘어 내가 원하는 값을 얻을 수 없음을 인지하여 코드를 수정하였고, 나머지 계산의 횟수를 줄이려다 잘못된 값을 얻는 실수를 저질러 아쉬웠다. 곱셈과 나눗셈 연산을 할 때 정수형 범위를 인지해야 함을 한번 더 생각하게 해주는 문제였다! 
