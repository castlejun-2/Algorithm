# **BaekJoon Online Judge**
## 1로 만들기 1463번
--- 
#### 정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

#### 1.X가 3으로 나누어 떨어지면, 3으로 나눈다.
#### 2.X가 2로 나누어 떨어지면, 2로 나눈다.
#### 3.1을 뺀다.
#### 4.정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

#### 1≤N≤10^6
---
## **_Code_**
```cpp
#include <iostream>
using namespace std;

int main(){
  int N=0;
  cin >> N;
  int* DP=new int[N+1];                                      //1부터 N까지의 각 자신의 숫자에 최소횟수를 담을 배열 동적할당
  DP[1]=0;
  
  for(int i=2;i<=N;i++){
    DP[i]=DP[i-1]+1;                                         //일반적으로 i는 i-1이 가진값에 +1이 더해진 값을 갖는다
    if(i%3==0)                                               //만약 i가 3으로 나누어진다면, i/3의 값에 3을 곱하면 자신임으로 DP[i/3]에 +1을 값을 가지고,
      DP[i]=DP[i]>DP[i/3]+1 ? DP[i/3]+1:DP[i];               //그 값과 현재 DP[i-1]+1로 얻어진 DP[i] 의 값중 더 작은 값을 선택하게 된다.
    if(i%2==0)                                               //만약 3과 2의 공배수가 나온다면 위의 if(i%3==0)의 조건문에서 얻어진 DP[i]값과
      DP[i]=DP[i]>DP[i/2]+1 ? DP[i/2]+1:DP[i];               //현재 이 조건문을 비교하여 더 작은값을 DP[i]는 선택하게 될 것이다.
  }   
  cout << DP[N] << endl;
  return 0;
}
```
---
## **_Key Code_**
```cpp
    DP[i]=DP[i-1]+1;                                         
    if(i%3==0)                                               
      DP[i]=DP[i]>DP[i/3]+1 ? DP[i/3]+1:DP[i];              
    if(i%2==0)                                             
      DP[i]=DP[i]>DP[i/2]+1 ? DP[i/2]+1:DP[i];
```
#### 위의 코드를 통한다면 DP[2] 부터 DP[N]까지의 값을 비교하여 작은 값들을 선택하여 N번의 반복을 하게 됨으로 O(N)을 갖는 코드를 만들어 줄 수 있으므로 위의 코드가 Key Code!
---
## **_Comment_**
#### 동적프로그래밍 기법중 하나인 Bottom-up 을 통해 작은 값부터 자신의 최소횟수 값을 구해 나아가는 기법을 통해 O(N)의 시간을 갖는 효율적인 코드를 짤 수 있었다! 하지만 아직 문제를 보자마자 해당 코드가 떠오르지 않아 시간이 좀 걸려서, 더 많은 문제를 보고 익히는 것이 앞으로도 중요할 것 같다!
