# **BaekJoon Online Judge**
## 계단오르기 2579번
--- 
#### 계단 오르는 데는 다음과 같은 규칙이 있다.

#### 1.계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.
#### 2.연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.
#### 3.마지막 도착 계단은 반드시 밟아야 한다.
#### 따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다. 하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세 번째 계단을 연속해서 모두 밟을 수는 없다.

#### 각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하는 프로그램을 작성하시오.

#### 계단의 개수≤300, 계단 점수≤10000
---
## **_Code_**
```cpp
#include <stdio.h>
int max(int a,int b){                                 //두 조건중 최대값 반환
  if(a>b) return a;
  else return b;
}  
int main(){
  int N=0;                                            //개단의 개수
  int a[300];                                         //각 개단의 점수
  int sum[300];                                       //각 개단까지의 최대합
    
  scanf("%d",&N);
  for(int i=0;i<N;i++) scanf("%d",a[i]);
  
  sum[0]=a[0];
  sum[1]=a[0]+a[1];
  sum[2]=max(a[0]+a[2],a[1]+a[2]);                    //3번째 계단부터 비교해줘야 할 대상이 생기고, 4번째 개단부터 규칙이 생기는것을 알 수 있다.
  
  for(int i=3;i<N;i++){
    sum[i]=max(sum[i-2]+a[i],sum[i-3]+a[i-1]+a[i]);   //2번의 조건으로 인하여, 이전(i-1)의 계단을 밟으면 전전(i-2)의 계단을 밟을 수 없으므로 전전전(i-3)까지의 최대합과
  }                                                   //더해주어야 하고, 이전(i-1)의 계단을 밟지 않았으면 전전(i-2)의 계단까지의 최대핪과만 더해주면 된다.
  
  printf("%d",sum[N-1]);
  return 0;
}
```
---
## **_Key Code_**
#### sum[i]=max(sum[i-2]+a[i],sum[i-3]+a[i-1]+a[i]); 를 통해 규칙에 맞는 코딩을 구현하는것이 중요포인트!
---
## **_Comment_**
#### 처음 알고리즘을 구현할 때 끝에서 부터 최대의 값을 찾아보려는 생각은 했으나, 일정 합을 구하는 sum[]에 대한 구현이 잘 떠오르지 않아 애를 먹은 문제이다. 입력크기가 작은(sum[0],sum[1],sum[2] 등등)과 같은 작은 부분의 문제들을 해결하여 저장해두고 그 값을 이용하여 최종적인(sum[N-1])을 구해야 함을 이해하는게 가장 중요했다고 생각한다. 최근 동적프로그래밍을 접하게 되면서 Memoization(메모이제이션)에 대해 알게 되었는데 어떤 것이 Memoization인지 좀 더 명확하게 알게 해주는 문제였다!
#### Memoization: 동일한 계산을 반복해야 할 때, 이전에 계산한 값들을 저장하여 반복수행을 제거하여 프로그램의 실행속도를 빠르게 해주는 기술 (위키백과 참조)
