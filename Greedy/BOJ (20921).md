# **BaekJoon Online Judge**
## 그렇고 그런 사이 20921번
---
#### 신수동 최고의 인싸 환주는 오늘도 인기가 많다. 그 인기는 정말 대단해서 대나무숲에서는 매일 환주의 이름이 쏟아진다.

#### 환주에게는 그 인기의 비결이 있었는데, 바로 자신이 원하는 두 명을 그렇고 그런 사이로 만들 수 있는 것이다!

#### 환주가 그렇고 그런 사이를 만드는 방법은 다음과 같다.

#### > 1번 사람부터 N번 사람까지 N명을 일렬로 세운다.
#### > 모든 사람에게 1부터 N까지 양의 정수 중 하나가 적힌 쪽지를 나눠준다. 쪽지에 적힌 정수는 중복되지 않는다.
#### > 서로 다른 두 사람을 골랐을 때, 왼쪽에 있는 사람이 오른쪽에 있는 사람보다 쪽지에 적힌 정수가 더 크다면, 이 두 사람은 그렇고 그런 사이가 된다.
#### > 놀랍게도 한 사람이 여러 사람과 그렇고 그런 사이일 수도 있다.
#### > 21세기의 큐피드 환주는 썸과 연애 상담이 너무 많이 와서 힘들다. 그래서 환주는 한 번에 여러 개의 그렇고 그런 사이를 만들려 한다. 하지만 너무 많이 만들면 미풍양속에 저해되고, 너무 적게 만들면 솔로들이 많아지기 때문에, 정확히 K개의 그렇고 그런 사이를 만들려 한다. 

#### 환주는 저 멀리서 달려오는 N명의 친구들을 보았다. 재빨리 K개의 그렇고 그런 사이를 만들어 주지 않으면, 저들은 환주의 안티팬이 될지도 모른다!

#### 2≤N≤4242, 0≤K≤N(N-1)/2
---
## **_Code_**
```cpp
#include <iostream>
using namespace std;

int main(){
  int N=0,K=0;
  cin >> N >> K;
  
  int* arr=new int[N+1];                            //배열 동적할당
  int num=1;                                        //나눠주게 될 쪽지의 값 초기화
  int index=N;                                      //배열의 인덱스 공간 변수 선언
  
  while(K!=0){                                      //그렇고 그런사이가 다 찰때까지 반복
    if(K>=index){                                   
      arr[index--]=num++;                           //그렇고 그런사이가 현재의 index 즉 남은공간보다 크다면 배열의 가장 뒤에 가장 작은 쪽지값 전달
      K-=index;                                     //남은 그렇고 그런사이는 N-1만큼 이전 명령문에서 달성했으므로 index만큼 빼준다.
    }
    else{
      arr[K+1]=num++;                               //그렇고 그런사이가 남은 공간보다 적게 남았다면 K+1공간에 현재 가장 작은 num을 주고 반복문 종료
      K=0;
    }
  }
  for(int i=1;i<=N;i++){                            //위의 else문에서 K+1에 가장 작은 값을 설정해주면 오름차순으로 정렬시 해당 남은 공간=index만큼 그렇고 그런사이가 형성됨
    if(arr[i]==0){                                  //배열이 차지 않은 부분들을 오름차순으로 쭉 전달
      cout << num++ << " ";
    }
    else{
      cout << arr[i] << " ";
    }
  }
  return 0;
}  
```
## **_Key Code_**
```cpp
if(K>=index){                                   
   arr[index--]=num++;                           
   K-=index;                                     
}
else{
   arr[K+1]=num++;                               
   K=0;
}
```
#### 그렇고 그런사이가 친구의 수보다 많다면 가장 뒤에 작은 값을 주어 N-1개의 그렇고 그런사이가 형성되도록 한 후 다시 형성된 그렇고 그런사이만큼 남은 그렇고 그런사이를 정립해준 후, 남은 그렇고 그런사이가 index보다 작아진다면 K+1(=남은 그렇고 그런 사이+1의 위치)에 현재의 가장 작은값(=num)을 넣고 앞의 값부터 오름차순으로 넣으면 그렇고 그런사이가 남은 K개만큼 형성된다는 것을 인지하는 것이 Key Code!
---
## **_Commnet_**
#### 이 문제는 결국 알고리즘을 구현하지 못해, 친구에게 한차례의 설명을 듣고 나서야 구현할 수 있었다. 하지만 그마저도 한번 더 이해하는데 시간이 좀 걸린 문제이다. 그 이유로 그리디 알고리즘을 적용할 알고리즘의 위치를 알지 못한 것이 가장 큰 이유라고 생각되어, 이런 어려운 문제를 좀 더 자주 접해 사고력을 기르는것이 중요할 것 같다,,!
